## 一、传递一维数组
* 将一维数组作为参数传递给函数，实际是通过值来传递数组地址，会提高传递效率。
* 因为不需要传递整个数组，这样就不要在栈中分配内存。
* 在函数中声明数组有两种方式

##### 1、用数组表示法
* 将一个整数数组及长度传递给函数
```
//定义函数
void displayArray(int arr[], int size){
    for (int i =0; i < size; i++){
        printf("%d \n",arr[i]);
    }
}

//使用函数
int arr[5] = {1,2,3,4,5};
displayArray(arr,5);
```
###### 注意：
* 1、sizeof操作符获取数组的长度是不对的，此数组sizeof为20，int类型4个字节，一共5个数据

#### 2、用指针表示法
```
//定义函数
void displayArray(int * arr , int size){
    for (int i = 0; i < size; i++){
        printf("%d  \n",arr[i]);
        printf(" %d", *(arr+i));
    }
}

//使用函数
int arr[5] = {1,2,3,4,5};
displayArray(arr,5);
```
## 二、使用指针的一维数组
```
    int * arr[5];
    for (int i = 0; i < 5; i++) {
        arr[i] = (int *) malloc(sizeof(int));
        *arr[i] = i;
    }

    for (int x = 0; x < 5; ++x) {
        printf("\n %d ",*arr[x]);
        printf("%d ",arr[x]);
    }
```
运行效果
```
 0 -255843296 
 1 -255851712 
 2 -255851696 
 3 -255842640 
 4 -255842624 
```
##### 代码说明
* 1、用arr[i]引用指针
* 2、用*arr[i]把指针赋值给指针引用的位置。
* 3、arr为指针数组，arr[i]返回的是地址，*arr[i]解引指针时得到是地址内容。

##### 在循环体中使用等价指针表示方法
```
*（arr+i)  = (int *) malloc(sizeof(int));
**(arr+i) = i;
```
* 1、表达式（arr+i）表示数组的第i个元素的地址，因为需要修改地址中的内容所以用表达式*(arr+i)
* 2、在第一条语句中将已分配的内存赋值给这个地址。
* 3、第二条语句中，对（arr+i）做两次解引，会返回所分配内存的位置，再把i赋值给它。

##### 内存说明
数组 | 数组地址| 指针地址| -->| 内容| 指针地址
---|---|---|---|---|---
arr[0]  | 100| 500|-->| 0| 500
arr[1]  | 104| 504|-->| 1| 504
arr[2]  | 108| 508|-->| 2| 508
arr[3]  | 112| 512|-->| 3| 512
arr[4]  | 116| 516|-->| 4| 516

####  总结
* arr = 100
* arr +1 = 104
* *(arr + 1 ) = 504
* **(arr + 1 ) = 1

##### 说明
* 1、arr[i]位于地址104
* 2、表达式（arr + 1）返回104
* 3、用*（arr+1）得到内容为指针504
* 4、用**（arr+1）解引它得到504的内容就是1

### 指针数组表达式

编号|表达式 | 值
---|---|---
1 |*arr[0] | 0
2 |**arr | 0
3 |**（arr+1） | 1
4 |arr[0][0] | 0
5 |arr[3][0] | 3
  
##### 说明：
* 表达式5：引用了arr的第四个元素，这个元素指向的数组的第1个元素


## 三、指针与多维数组
##### 1、二维数组
```
    int arr[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};
    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 5; y++) {
            printf(" arr[%d][%d]  address: %p  value:  %d\n",x,y,&arr[x][y],arr[x][y]);
        }
    }
```
运行效果
```
 arr[0][0]  address: 0x7ffee1422b10  value:  1
 arr[0][1]  address: 0x7ffee1422b14  value:  2
 arr[0][2]  address: 0x7ffee1422b18  value:  3
 arr[0][3]  address: 0x7ffee1422b1c  value:  4
 arr[0][4]  address: 0x7ffee1422b20  value:  5
 arr[1][0]  address: 0x7ffee1422b24  value:  6
 arr[1][1]  address: 0x7ffee1422b28  value:  7
 arr[1][2]  address: 0x7ffee1422b2c  value:  8
 arr[1][3]  address: 0x7ffee1422b30  value:  9
 arr[1][4]  address: 0x7ffee1422b34  value:  10
```
* 1、数组按行，列顺序存储
* 2、将第一行存入内存后再将第二行存入内存。

##### 2、修改
```
    int (*aa)[5] = arr;
    printf("%p  \n",arr);
    printf("%p  \n",arr+1);
```
* 1、(*aa)表达式声明了一个数组指针
* 2、int (*aa)[5] = arr：将aa定义为一个指向二维数组的指针，二维数组int类型，每列有5个元素
* 3、如果把括号去掉就声明了5个元素的数组，数组元素的类型是整数指针
* 4、如果声明的列数不少5，该指针访问数组的结果则是不可预期的。

##### 运行效果：
```
0x7ffeecf95b10  
0x7ffeecf95b24 
```
* 1、arr+1:返回的地址不是从数组开头偏移4，而是偏移了第一行的长度20个字节
* 2、用arr返回数组第一个元素的地址，二维数组是数组的数组
* 3、所以得到是一个拥有5个元素的整数数组地址长度为20.---sizeof（arr[0]）;

#### 3、访问数组的第二个元素
* 需要给数组的第一行加上1
```
printf("%p  %d \n", arr[0]+1,*(arr[0]+1));
```
* 1、表达式arr[0]返回数组的第一行第一个元素的地址，这个地址是一个整数数组的地址
* 2、给它加1，实际加的是一个整数长度，得到的是第二个数组。

## 四、传递多维数组
