## 一、指针和内存
* 程序在编译后会形成三种方式使用内存

#### 1、静态/全局内存
* 1、静态变量，全局变量使用此部分内存
* 2、此变量在程序开始运行时分配，程序结束时才消失。
* 3、所有函数都能分全局变量，静态变量的作用域局限在第一他们的函数内部。

#### 2、自动内存
* 1、在函数内部声明，在函数被调用时才创建。
* 2、作用域在函数内部，生命周期在函数执行时间内

#### 3、动态内存
* 1、分配在堆上，根据需求释放，到释放才消失。
* 2、指针引用分配的内存，作用域局限于引用内存的指针

#### 4、内存作用域和生命周期
内存 | 作用域 | 生命周期
----|------|----
全局作用域 | 整个文件  | 应用程序生命周期
静态内存 | 函数内部  | 应用程序的生命周期
局部内存 | 函数内部  | 函数的执行时间
动态内存 | 引用内存的指针决定  | 内存释放

#### 5、总结
* 1、指针变量包含内中别的变量、对象获取函数的地址
* 2、对象：就是内存中分配函数分配的内存，对象可以是任何C数据类型
* 3、指针：通常根据所指的数据类型来声明，指针本身并没有包含所引用数据的类型信息，只包含地址。

## 二、声明指针
* 通过在数据类型后面跟星号，加上指针变量名称可以声明指针
* 如： 
```
int num;
int * pi;
```
### 1、特点：
* 1、pi的内容最终应该赋值一个整数变量的地址
* 2、这些变量没有被初始化，所以包含的是垃圾数据。
* 3、指针的实现中没有内部信息表明自己指向的是什么类型的数据或内容是否合法。
* 4、指针有类型，如果内心不对编译器会报错。

### 2、内存垃圾
* 是指分配的内存中可能包含任何数据
* 1、当内存刚分配时不会被清理，之前的内容可能是任何东西。

### 3、阅读声明
```
const int *pic;
```
#### 阅读
* 1、pic：pic的一个变量
* 2、* pic：pic是一个指针变量
* 3、int * pic：pic是一个指向整数的指针变量
* 4、const int * pic：pic是一个指向整数常量的指针变量

## 三、地址操作符
#### 1、地址操作 
* 地址操作符&会返回操作数的地址可以用这个操作符累初始化指针；

```
num =0;
pi = & num;
```
* num变量设置为0，而pi设置为指向num的地址。

#### 2、内存赋值
* 在声明变量pi的同时把它初始化为num的地址
```
int num;
int * pi = &num;
```
##### 3、如果以下语法将会报错
```
num =0；
pi = num;
```
* pi变量的类型是整数指针，num类型是整数，整数不能转换为指向整数类型的指针。

##### 4、将整数转换为指向整数的指针
```
pi = (int * )num;
```
* 此语法正确，使用0作为地址很多地方是不合法的

#### 5、指针初始化
```
int num;
int * pi;
pi = & num;
```
## 四、打印指针的指
```
int num = 0;
int * pi = &num;
printf("%d, %d \n",&num,num);
printf("%d, %d \n",&pi,pi);
```
* 运行效果：
```

```
